# object orientated programming 
> with python 

## overview
- object orientated programming is a way of working with and organizing data
- OOJ uses classes to create models for future objects, or "subclasses"


## creating classes
- we create a new class by using the "class" keyword
- def means "define", as in "define this function"
- a method is just a function that is inside of an object or class
- when we create a class, the __init__() method is ran everytime we create a new object from that class

## init 
- we can define additional functionality for the __init__() method when creating classes
- def __init__ is saying "define initialization method"
- __init__ may also be known as "initializer" or "constructor"
- __init__ will be created with the "self keyword"


## self
- the "self" keyword is the equivalent of the "this" keyword in other languages
- it stands for the future object that will be created from this class
- any methods we create inside of our classes will use the "self" keyword

## attributes
- class attributes can be reassigned directly the same way a variable would be reassigned

## methods
- a method is a function that is defined when creating a class 
- methods can be called from objects 
- methods must have the "self" keyword passed in as a parameter
- we do not call the "self" keyword as an argument when calling a method
- methods must have at least 1 argument
- when calling methods, "self" is automatically passed in, even if we do not write it in the method

## static methods
- a special method which just does not take any arguments
- gets called on the Class directly
- can give information about the class

## built-in class methods

- besides __init__ there is __str__()
- this is called whenever we print an object
- normally it prints out the objects location in memory 
- we can override this method to return the data we specify from the class


## example code
```
class Customer: 
    def __init__(self, name, password, membership_type):
        print("customer initialized")
        self.name = name
        self.password = password
        self.membership_type = membership_type

    def update_membership(self, new_membership):
        print("making GET request to API to update membership")
        self.membership_type = new_membership

    def update_password(self, new_password):
        print("making POST request to API to update password")
        self.password = new_password

    # broken code
    def print_customer():
        print("printing customer data")

    # fixed code
    def print_customers():
        print("printing customer data")

    # override the __str_ method
    def __str__(self):
        return self.name + " " + self.membership_type

    def print_all_customers(customers):
        for customer in customers:
            print(customer)

    def __eq__(self, other):
        if self.name == other.name and self.membership_type == other.membership_type:
            return True

        return False

    
    __repr__ = __str__




customer1 = Customer("Justin", "Premium")
print(customer1.name)
print(customer1.membership_type)

customer2 = Customer("Tyler", "Free")
print(customer2.name)
print(customer2.membership_type)


customers = [customer1, customer2, Customer("Alex", "Free"), Customer("Rodger", "Premium")]  


customer1.update_membership("Gold")
print(customer1.membership_type)
# pointless method, attributes may be modified directly

customer2.membership_type = "Premium"
print(customer2.membership_type)


# throws error
customer1.print_customer()

# does not throw error 
Customer.print_customers()

# without overriding the __str__ method outputs the datatype as an object and its location in memory 
print(customer1)

Customer.print_all_customers(customers)

print(customer1 == customer2)
# prints false

print(id(customer1), id(customer2))

# override __repr__ method 

print(customers)

```
